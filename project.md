---

## Описание

Данный проект представляет собой программное решение, обрабатывающее **упрощённое подмножество синтаксических конструкций языка Python** без традиционной компиляции. Требуется реализовать механизмы анализа языка (лексический, синтаксический, семантический), а также модуль исполнения, поддерживающий базовые операции и типы данных. Интерпретатор должен корректно выполнять Python-код, отображать результаты, вести логи, обрабатывать возможные ошибки и обеспечивать возможность проведения тестирования для проверки корректности работы системы.

---

## Базовые требования

### Требования к языку

**Характеристика языка**:

- **Парадигма:** императивная, процедурная, структурная (упрощённый взгляд на Python).
- **Типизация:** динамическая, строгая (тип меняется в рантайме, но не смешивается автоматически без явных преобразований).
  
**Структура кода**:

1. **Блочная структура с использованием отступов**: в Python нет фигурных скобок `{}`, поэтому вложенность и границы блоков кода определяются уровнем отступа (пробелы или табуляция, но в одном проекте строго единообразно).
2. **Завершение инструкции**: в Python инструкции завершаются переводом строки. Точки с запятой `;` не требуются (хотя в отдельных случаях допустимы, но в упрощённом подмножестве мы можем не поддерживать их).
3. **Точка входа**: в классическом Python нет обязательной функции `main`. Код исполняется последовательно сверху вниз. При необходимости можно условиться, что при наличии функции `main()`, интерпретатор будет сначала вызывать её.
4. **Разрешение идентификаторов**: переменные могут объявляться присваиванием «на лету», однако для корректной работы интерпретатора важно отслеживать их в **области видимости** (scope).
5. **Структура единицы трансляции**: упрощённо, любая программа Python может состоять из:
   - Определений функций `def`
   - Обычных инструкций (присваивания, выражения, управляющие конструкции и т.д.)
   - В нашем упрощённом подмножестве **не предполагается** использование классов или аналогов `struct` (т.к. это не заявлено в базовом ТЗ).
6. **Комментарии**: поддержка однострочных комментариев через `#` и многострочных — через тройные кавычки `""" ... """`.

**Поддержка**:

- **Типы данных**:
  - Примитивные (int, float, bool, str)
  - Допускается работа со списками (аналог одномерных массивов), но без сложных операций вроде срезов (если не требуется базовым ТЗ).
  - Отдельный тип `None` может использоваться для функций, которые ничего не возвращают.

- **Литералы**:
  - Целые (десятичные, например, `42`)
  - Вещественные (например, `3.14`)
  - Логические (`True`, `False`)
  - Строковые (например, `"hello"`, с поддержкой escape-последовательностей `\n`, `\t` и т.д.)

- **Операторы**:
  - Арифметические: `+`, `-`, `*`, `/`, `//` (целочисленное деление), `%`
    - Унарные операторы `+`, `-` также поддерживаются (например, `-x`).
    - **Инкремент/декремент** в стиле `++i`, `i--` в Python отсутствуют, поэтому они не реализуются.
  - Логические: `not`, `and`, `or`
  - Сравнение: `==`, `!=`, `>`, `<`, `>=`, `<=`
  - Присваивание: `=`, `+=`, `-=`, `*=`, `/=`, `//=`, `%=`
  - **sizeof** и C-style преобразования типов не поддерживаются в Python; для приведения типов используются функции `int()`, `float()` и т.д. (по необходимости).
  - Тернарный оператор в Python: `x if condition else y`.
  - Операторы индексирования `[]` для списков.
  - Операторы вызова функций `()`.

- **Управляющие конструкции**:
  - Условные: `if`, `elif`, `else`
  - Циклы: 
    - `while`
    - `for <var> in <iterable>` (упрощённо можно считать `range(...)`)
    - Конструкции наподобие `do-while` в Python нет, поэтому **не** реализуется.
  - Переходы:
    - `break`
    - `continue`
    - `return`
- **Функции**: 
  - Описываются через ключевое слово `def`. 
  - Поддерживается рекурсия.
- **Ввод/вывод**:
  - Чтение: `input()` (в нашем интерпретаторе может быть реализовано как встроенная функция `read()` с аналогичным поведением).
  - Вывод: `print()`.
- **Другое**:
  - Квалификатора `const` нет.
  - Использование `assert` для отладки.
  - Выход из программы через встроенную функцию (например, `exit()` или аналог). 

---

## Требования к интерпретатору

1. **Механизмы анализа кода**:
   - **Лексический анализ**: корректно разбивать входной Python-код на лексемы (идентификаторы, литералы, операторы, ключевые слова, пробелы/переводы строк и т.д.).
   - **Синтаксический анализ**: разбирать полученные лексемы в соответствии с упрощённой Python-грамматикой.
   - **Семантический анализ**: проверять корректность использования переменных, функций, область видимости и т.д. (на базовом уровне, без сложного вывода типов).
   - **Оптимизация кода**: (по необходимости, минимальная); в Python обычно оптимизация во время интерпретации не так критична, но если есть требования базового ТЗ — можно учитывать, например, простейшие оптимизации константных выражений.

2. **Модуль исполнения**:
   - Интерпретировать разобранное дерево (AST) в правильном порядке.
   - Выполнять базовые операции и типовые конструкции Python.
   - Обеспечивать корректность работы со стеком вызовов (для функций, рекурсии и т.д.).

3. **Логирование**:
   - Фиксация лексических, синтаксических и семантических ошибок.
   - Возможность включать/выключать отладочные сообщения при выполнении кода.

4. **Обработка ошибок**:
   - При возникновении непредвиденных ситуаций (например, синтаксическая ошибка) выдавать понятное сообщение об ошибке и корректно завершать интерпретацию конкретного блока (или всей программы).
   - Обрабатывать ошибки времени выполнения (деление на ноль, выход за границы списка и т.п.) путём генерации соответствующих исключений или логов.

5. **Тестирование**:
   - Наличие набора тестов, покрывающих все ключевые аспекты языка (арithmetic, логика, условия, циклы, функции и т.д.).
   - Автоматический запуск тестового пакета и вывод результатов.

---

## Лексер

В упрощённом подмножестве Python можно выделить основные типы лексем:

1. **Идентификаторы (`<id>`)**  
   - Любая последовательность букв, цифр и подчёркиваний, не начинающаяся с цифры.  
   - Примеры: `x`, `myVar`, `_internal`, `abc123`.

2. **Литералы (`<literals>`)**  
   - Целые числа (например, `42`)
   - Вещественные числа (например, `3.14`)
   - Строки (например, `"hello"`, `'world'`, с поддержкой escape-последовательностей)
   - Логические (`True`, `False`)
   - `None`

3. **Ключевые слова (`<keyword>`)**  
   - В частности, `def`, `if`, `elif`, `else`, `while`, `for`, `in`, `break`, `continue`, `return`, `True`, `False`, `None`, `and`, `or`, `not`, `assert`, `input`, `print`, `exit`, и т.д. (строго ограниченный набор в соответствии с базовыми требованиями).

4. **Операторы (`<operators>`)**  
   - `+`, `-`, `*`, `/`, `//`, `%`, `+=`, `-=`, `*=`, `/=`, `//=`, `%=`, `==`, `!=`, `>`, `<`, `>=`, `<=`, `=`, `and`, `or`, `not`, `if`, `else`, `elif`, `return`, `break`, `continue`, `:` (двоеточие для начала блока).
   - Тернарная форма: `x if condition else y`.
   - `()` для вызовов, `[]` для индексации списков.

5. **Разделители (`<punctuator>`)**  
   - Пробелы и символы перевода строки (в Python критически важны для структуры).
   - Возможна запятая `,` (например, для перечисления параметров функции).

6. **Комментарии**  
   - Однострочные: `# комментарий до конца строки`
   - Многострочные: `""" многострочный комментарий """` (упрощённо можно обрабатывать как несколько строк).

---

## Грамматика

С учётом упрощённого подмножества Python, мы сохраняем три общих сущности (как указано в базовом ТЗ): **выражения**, **инструкции**, **объявления**. Но адаптируем их под специфику Python: 

### 1. Объявления

В Python нет отдельных объявлений переменных, поэтому в упрощённом виде **объявлением** считается:
- **Определение функции**.  
- (Не используем `struct`, поскольку базовое ТЗ упоминает структуры только в контексте языка, похожего на C++: здесь убираем это требование.)
- Любая инструкция верхнего уровня (например, присвоение) формально тоже является «объявлением»/«выполнимой частью» в Python-файле.

Таким образом, упрощённая «единица трансляции» может быть описана так:

```
<translation_unit> = (<func_decl> | <statement>)* 
```

Где `<func_decl>` — объявление функции, а `<statement>` — любая инструкция верхнего уровня.

#### Определение функции

```python
<func_decl> = 'def' <id> '(' <param_decl>? (',' <param_decl>)* ')' ':' <block_st>
```

- `<param_decl>` в Python не требует явного типа: 
  ```
  <param_decl> = <id>
  ```
- Возврат функции осуществляется инструкцией `return`.

### 2. Инструкции

В Python каждая инструкция определяется уровнем отступа и синтаксисом. Для упрощения отразим это в виде:

```
<statement> = <expr_st>
             | <conditional_st>
             | <loop_st>
             | <return_st>
             | <continue_st>
             | <break_st>
             | <block_st>
             | <pass_st>         # Иногда pass упрощает синтаксис
             | <assert_st>
             | <exit_st>
```

Ниже — основные варианты:

- **Выражение**:

  ```python
  <expr_st> = <expr> NEWLINE
  ```
  Здесь `NEWLINE` означает конец строки.

- **Условное**:

  ```python
  <conditional_st> = 'if' <expr> ':' <block_st> ('elif' <expr> ':' <block_st>)* ('else' ':' <block_st>)?
  ```

- **Циклы**:
  - `while`:

    ```python
    <while_st> = 'while' <expr> ':' <block_st>
    ```
  
  - `for`:

    ```python
    <for_st> = 'for' <id> 'in' <expr> ':' <block_st>
    ```
  
  - `do-while` отсутствует в Python, поэтому здесь не реализуется.

  Следовательно:
  
  ```python
  <loop_st> = <while_st> | <for_st>
  ```

- **Переходы**:
  - `return`:

    ```python
    <return_st> = 'return' <expr>? NEWLINE
    ```
    (В Python `return` может быть и без выражения, возвращая `None`.)

  - `break`:

    ```python
    <break_st> = 'break' NEWLINE
    ```

  - `continue`:

    ```python
    <continue_st> = 'continue' NEWLINE
    ```

- **Блок** (в Python — совокупность инструкций с одинаковым уровнем отступа):

  ```python
  <block_st> = INDENT <statement>* DEDENT
  ```
  
  Где `INDENT`/`DEDENT` — условные обозначения для увеличения/уменьшения уровня отступа.

- **Пустая инструкция (pass)**:

  ```python
  <pass_st> = 'pass' NEWLINE
  ```

- **Утверждения (assert)**:

  ```python
  <assert_st> = 'assert' <expr> (',' <expr>)? NEWLINE
  ```
  (В Python `assert` может принимать второе выражение как сообщение.)

- **Выход**:

  ```python
  <exit_st> = 'exit' '(' <expr>? ')' NEWLINE
  ```
  (Или можно считывать `exit()` как встроенную функцию.)

### 3. Выражения

Упрощённо, выражения в Python могут быть:

1. **Простое выражение** (числа, строки, идентификаторы, вызовы функции, индексация и т.д.):
   ```python
   <expr> = <or_expr>  # где or_expr включает в себя последовательность логических операций
   ```
   В полном Python-спеке много уровней приоритетов (`or`, `and`, `not`, `==`, `+`, `-`, `*`, `**`, и т.д.). В упрощённом варианте можно придерживаться укрупнённой схемы:

   ```
   <or_expr> = <and_expr> ('or' <and_expr>)*
   <and_expr> = <not_expr> ('and' <not_expr>)*
   <not_expr> = ('not')* <comparison_expr>
   <comparison_expr> = <arith_expr> (('==' | '!=' | '<' | '>' | '<=' | '>=') <arith_expr>)*
   <arith_expr> = <term> (('+' | '-') <term>)*
   <term> = <factor> (('*' | '/' | '//' | '%') <factor>)*
   <factor> = (('+' | '-') <factor>)? <power>
   <power> = <primary> ('**' <factor>)?  # если хотим поддержать возведение в степень
   <primary> = <literal_expr> | <id_expr> | <call_expr> | <index_expr> | '(' <expr> ')' | <ternary_expr>
   ```

2. **Тернарное выражение**:  
   ```python
   <ternary_expr> = <expr> 'if' <expr> 'else' <expr>
   ```
   

3. **Вызов функции**:
   ```python
   <call_expr> = <id_expr> '(' <expr>? (',' <expr>)* ')'
   ```
4. **Индексирование**:
   ```python
   <index_expr> = <id_expr> '[' <expr> ']'
   ```
5. **Идентификатор**:
   ```python
   <id_expr> = <id>
   ```

---

### Итого

В результате данное техническое задание на написание интерпретатора **упрощённого подмножества языка Python** включает:

1. **Лексер**, разделяющий код на токены (идентификаторы, литералы, ключевые слова, операторы, пробелы/переводы строк, комментарии).
2. **Синтаксический анализатор**, строящий упрощённое дерево разбора (AST) по описанной грамматике.
3. **Семантический анализ**, проверяющий правильность использования имён переменных/функций и соответствие базовым правилам Python (область видимости, корректность количества параметров при вызове и т.п.).
4. **Модуль исполнения (интерпретатор)**, который:
   - Выполняет код, поддерживает основные операции, типы (int, float, bool, str), списки, и базовые управляющие конструкции (if, elif, else, for, while, break, continue, return).
   - Реализует базовые встроенные функции: `print()`, `input()`, `assert`, `exit()`.
   - Отслеживает контекст (стек вызовов, локальные и глобальные переменные).
5. **Логирование** (ошибки лексического, синтаксического, семантического уровней, а также ошибки времени выполнения).
6. **Обработка ошибок** (некорректный синтаксис, несуществующие идентификаторы, некорректные операции и т.д.).
7. **Тестирование** (набор тестов на каждую ключевую конструкцию языка и механизм интерпретации).
